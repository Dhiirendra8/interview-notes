Java ‡§Æ‡•á‡§Ç **Fork/Join Framework** ‡§è‡§ï ‡§ê‡§∏‡§æ mechanism ‡§π‡•à ‡§ú‡•ã **large tasks ‡§ï‡•ã ‡§õ‡•ã‡§ü‡•á subtasks ‡§Æ‡•á‡§Ç divide** ‡§ï‡§∞‡§ï‡•á **parallel execution** ‡§ï‡•Ä ‡§∏‡•Å‡§µ‡§ø‡§ß‡§æ ‡§¶‡•á‡§§‡§æ ‡§π‡•à ‚Äî ‡§Ø‡§æ‡§®‡•Ä **multi-core processors** ‡§ï‡•Ä ‡§§‡§æ‡§ï‡§§ ‡§ï‡§æ ‡§Ö‡§ö‡•ç‡§õ‡•á ‡§∏‡•á ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§

---

## üîπ Fork/Join Framework ‡§ï‡•ç‡§Ø‡§æ ‡§π‡•à?

> ‡§Ø‡§π Java 7 ‡§Æ‡•á‡§Ç introduce ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§•‡§æ (`java.util.concurrent` package ‡§Æ‡•á‡§Ç), ‡§î‡§∞ ‡§Ø‡•á specially **divide and conquer** algorithm ‡§ï‡•á ‡§≤‡§ø‡§è design ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§

---

## üîë Main Concepts

| Term                 | Explanation                                       |
| -------------------- | ------------------------------------------------- |
| **Fork**             | Task ‡§ï‡•ã ‡§õ‡•ã‡§ü‡•á-‡§õ‡•ã‡§ü‡•á subtasks ‡§Æ‡•á‡§Ç divide ‡§ï‡§∞‡§®‡§æ        |
| **Join**             | Subtasks ‡§ï‡§æ result ‡§Æ‡§ø‡§≤‡§æ‡§ï‡§∞ final result ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§ï‡§∞‡§®‡§æ |
| **RecursiveTask<T>** | Return value ‡§µ‡§æ‡§≤‡•á task ‡§ï‡•á ‡§≤‡§ø‡§è                     |
| **RecursiveAction**  | Return value **‡§®‡§π‡•Ä‡§Ç** ‡§¶‡•á‡§®‡•á ‡§µ‡§æ‡§≤‡•á task ‡§ï‡•á ‡§≤‡§ø‡§è       |
| **ForkJoinPool**     | Task ‡§ï‡•ã manage ‡§î‡§∞ execute ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ pool          |

---

## ‚úÖ Example: Sum of Array Using Fork/Join

```java
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.ForkJoinPool;

class SumTask extends RecursiveTask<Long> {
    private final int[] arr;
    private final int start, end;
    private static final int THRESHOLD = 5;

    public SumTask(int[] arr, int start, int end) {
        this.arr = arr;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // Base case: directly compute
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += arr[i];
            }
            return sum;
        } else {
            // Fork into two subtasks
            int mid = (start + end) / 2;
            SumTask left = new SumTask(arr, start, mid);
            SumTask right = new SumTask(arr, mid, end);

            left.fork(); // run asynchronously
            long rightResult = right.compute(); // run synchronously
            long leftResult = left.join(); // wait for left to finish

            return leftResult + rightResult;
        }
    }
}
```

---

### üîΩ Driver Code

```java
public class ForkJoinExample {
    public static void main(String[] args) {
        int[] numbers = new int[20];
        for (int i = 0; i < 20; i++) numbers[i] = i + 1;

        ForkJoinPool pool = new ForkJoinPool();
        SumTask task = new SumTask(numbers, 0, numbers.length);

        long result = pool.invoke(task);
        System.out.println("Total sum = " + result); // Output: 210
    }
}
```

---

## üß† Summary

| Feature           | Fork/Join Framework                                |
| ----------------- | -------------------------------------------------- |
| Introduced In     | Java 7 (`java.util.concurrent`)                    |
| Best Used For     | Divide and conquer problems                        |
| Core Classes      | `ForkJoinPool`, `RecursiveTask`, `RecursiveAction` |
| Efficient Because | Uses **work-stealing algorithm** internally        |
| Parallelism       | Runs tasks in parallel using multiple threads      |

---

‡§Ö‡§ó‡§∞ ‡§ö‡§æ‡§π‡•ã ‡§§‡•ã ‡§Æ‡•à‡§Ç real-world problem ‡§ú‡•à‡§∏‡•á **parallel file processing**, **matrix multiplication**, ‡§Ø‡§æ **web crawling** ‡§ï‡•á ‡§≤‡§ø‡§è Fork/Join ‡§ï‡§æ example ‡§≠‡•Ä ‡§¶‡•á ‡§∏‡§ï‡§§‡§æ ‡§π‡•Ç‡§Å‡•§
